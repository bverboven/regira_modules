{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/utilities/array-utility.js","webpack:///./src/treelist/tree-node.js","webpack:///./src/treelist/tree-utility.js"],"names":["root","factory","exports","module","define","amd","a","i","window","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","selfSelector","x","isArray","items","Array","isIterable","iterator","toArray","values","except","items1","items2","selector1","selector2","arr2","filter","some","y","distinct","Set","TreeNode","parent","tree","this","_value","_parent","_level","level","_tree","_children","parents","add","getOffspring","getAncestors","getRoots","children","child","toNodes","nodes","flatMap","node","getNodes","findParents","fkSelector","parentsSelector","parentValues","parentFilter","includes","addValue","addedNodes","console","debug","parentNodes","length","parentNode","_nodes","push"],"mappings":"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","file":"tree-utility.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","import { filterObject } from './object-utility';\r\nimport { naturalCompare, getRandom } from './number-utility';\r\n\r\nconst selfSelector = x => x;\r\nconst compareAsc = (a, b, f) => f(a) < f(b) ? -1 : f(a) > f(b) ? 1 : 0;\r\nconst compareDesc = (a, b, f) => f(a) > f(b) ? -1 : f(a) < f(b) ? 1 : 0;\r\n\r\nexport const isArray = items => Array.isArray(items);\r\nexport const isIterable = items => items != null && typeof (items[Symbol.iterator]) === 'function';\r\nexport const toArray = items => isArray(items) ? items : (isIterable(items) ? [...items] : Object.values(items));\r\nexport const newArray = length => [...Array(length)];\r\n\r\nexport const orderBy = (items, selector = selfSelector) => {\r\n    const arr = [...items];\r\n    arr.sort((a, b) => compareAsc(a, b, selector));\r\n    return arr;\r\n};\r\nexport const orderByDesc = (items, selector = selfSelector) => {\r\n    const arr = [...items];\r\n    arr.sort((a, b) => compareDesc(a, b, selector));\r\n    return arr;\r\n};\r\nexport const naturalSort = (items, selector = selfSelector) => {\r\n    const arr = [...items];\r\n    arr.sort((a, b) => naturalCompare(a, b, selector));\r\n    return arr;\r\n};\r\nexport const shuffle = items => {\r\n    const source = [...items];// copy array\r\n    return [...Array(source.length)]\r\n        .map(() => {\r\n            const index = getRandom(source.length - 1);\r\n            return source.splice(index, 1)[0];\r\n        });\r\n};\r\nexport const innerJoin = (items1, items2, selector1 = selfSelector, selector2 = selfSelector, resultSelector = selector1) => {\r\n    const result = [];\r\n    const arr1 = toArray(items1);\r\n    const arr2 = toArray(items2);\r\n    arr1.forEach(x => {\r\n        const joinedItems = arr2.filter(y => selector1(x) === selector2(y));\r\n        joinedItems.forEach(y => {\r\n            result.push(resultSelector(x, y));\r\n        });\r\n    });\r\n    return result;\r\n};\r\nexport const groupBy = (items, keySelector) => {\r\n    return [...toMap(items, keySelector, (v, i, map) => {\r\n        const key = keySelector(v);\r\n        if (!map.has(key)) {\r\n            return [v];\r\n        }\r\n        const currentValue = map.get(key);\r\n        return currentValue.concat(v);\r\n    })];\r\n    // const keys = distinct(arr.map(keySelector));\r\n    // return keys.map(key => [key, arr.filter((y, j, arr2) => key === keySelector(y, j, arr2))]);\r\n};\r\nexport const groupJoin = (parentItems, childItems, parentKeySelector = selfSelector, childSelector = selfSelector, resultSelector = (parent, children) => [parent, children]) => {\r\n    const childArr = toArray(childItems)\r\n    return toArray(parentItems)\r\n        .map((x, i, parents) => [x, childArr.filter((y, j, children) => parentKeySelector(x, i, parents) === childSelector(y, j, children))])\r\n        .map(([groupedKey, groupedValues]) => resultSelector(groupedKey, groupedValues));\r\n};\r\nexport const except = (items1, items2, selector1 = selfSelector, selector2 = selfSelector) => {\r\n    const arr2 = toArray(items2);\r\n    return toArray(items1).filter(x => !arr2.some(y => selector1(x) === selector2(y)));\r\n};\r\nexport const count = (items, predicate) => {\r\n    const arr = toArray(items);\r\n    return predicate ? arr.filter(predicate).length : arr.length;\r\n};\r\nexport const first = (items, predicate) => {\r\n    const arr = toArray(items);\r\n    if (!predicate) {\r\n        return arr[0];\r\n    }\r\n    return arr.find(predicate);\r\n};\r\nexport const last = (items, predicate) => {\r\n    const arr = toArray(items);\r\n    if (!predicate) {\r\n        return arr.length ? arr[arr.length - 1] : undefined;\r\n    }\r\n    for (let i = arr.length - 1; i >= 0; i--) {\r\n        if (predicate(arr[i])) {\r\n            return arr[i];\r\n        }\r\n    }\r\n    return undefined;\r\n};\r\nexport const distinctBy = (items, selector) => {\r\n    const arr = toArray(items);\r\n    return arr.reduce((r, v) => r.some(x => selector(x) === selector(v)) ? r : r.concat([v]), []);\r\n};\r\nexport const distinct = (items) => {\r\n    return [...new Set(items)];\r\n    //return distinctBy(items, selfSelector);\r\n};\r\nexport const union = (arr1, arr2) => {\r\n    return distinct(toArray(arr1).concat(toArray(arr2)));\r\n};\r\nexport const take = (items, n) => {\r\n    return toArray(items).slice(0, n);\r\n};\r\nexport const skip = (items, n) => {\r\n    return toArray(items).slice(n);\r\n};\r\nexport const page = (items, pageSize, pageIndex = 0) => {\r\n    const skip = pageSize * pageIndex;\r\n    return toArray(items).slice(skip, skip + pageSize);\r\n};\r\nexport const countPages = (items, pageSize) => {\r\n    const totalSize = toArray(items).length;\r\n    return Math.ceil(totalSize / pageSize);\r\n};\r\n\r\nexport const min = (items, selector = selfSelector) => {\r\n    //return Math.min(...items.map(selector)); -> only numeric\r\n    const arr = toArray(items);\r\n    if (!arr.length) {\r\n        return undefined;\r\n    }\r\n    return arr\r\n        .reduce((r, x) => {\r\n            const v = selector(x);\r\n            return (r == null || v < r) ? v : r;\r\n        }, null);\r\n};\r\nexport const max = (items, selector = selfSelector) => {\r\n    //return Math.max(...items.map(selector)); -> only numeric\r\n    const arr = toArray(items);\r\n    if (!arr.length) {\r\n        return undefined;\r\n    }\r\n    return arr\r\n        .reduce((r, x) => {\r\n            const v = selector(x);\r\n            return (r == null || v > r) ? v : r;\r\n        }, null);\r\n};\r\nexport const sum = (items, selector = selfSelector) => {\r\n    return toArray(items)\r\n        .reduce((r, x) => r + selector(x), 0);\r\n};\r\nexport const average = (items, selector) => {\r\n    return sum(items, selector) / items.length;\r\n};\r\nexport const toMap = (items, keySelector, valueSelector = selfSelector) => {\r\n    const arr = toArray(items);\r\n    return arr.reduce((map, item, i) => {\r\n        const key = keySelector(item);\r\n        const value = valueSelector(item, i, map);\r\n        return map.set(key, value);\r\n    }, new Map());\r\n    // const entries = groupBy(items, keySelector).map(x => [x[0], x[1].map(valueSelector)]);\r\n    // return new Map(entries);\r\n};\r\nexport const sameContent = (items1, items2, includeOrder = true) => {\r\n    if (items1 === items2) {\r\n        return true;\r\n    }\r\n    if (items1 == null || items2 == null) {\r\n        return false;\r\n    }\r\n    const arr1 = toArray(items1);\r\n    const arr2 = toArray(items2);\r\n    if (arr1.length !== arr2.length) {\r\n        return false;\r\n    }\r\n    if (includeOrder) {\r\n        for (let i = 0; i < arr1.length; i++) {\r\n            if (arr1[i] !== arr2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    // same order not required\r\n    return innerJoin(arr1, arr2).length === arr1.length;\r\n};\r\n\r\nexport const query = (items, filter) => {\r\n    const arr = toArray(items);\r\n    return arr.filter(x => filterObject(x, filter));\r\n};\r\nexport const getEnumerator = (arr) => {\r\n    let index = 0;\r\n    return {\r\n        get selectedIndex() { return index; },\r\n        set selectedIndex(value) {\r\n            if (value >= 0 && value < arr.length) {\r\n                index = value;\r\n            }\r\n        },\r\n        get length() { return arr.length; },\r\n        get current() {\r\n            if (index >= 0 && index < arr.length) {\r\n                return arr[index];\r\n            }\r\n            return null;\r\n        },\r\n        first() {\r\n            index = 0;\r\n        },\r\n        previous() {\r\n            if (index > 0) {\r\n                index--;\r\n            }\r\n            return index > 0;\r\n        },\r\n        next() {\r\n            if (index < arr.length - 1) {\r\n                index++;\r\n            }\r\n            return index < arr.length;\r\n        },\r\n        last() {\r\n            index = arr.length - 1;\r\n        }\r\n    };\r\n};\r\n\r\n// no pure functions\r\nexport const move = (arr, item, pos) => {\r\n    const index = arr.indexOf(item);\r\n    if (index !== -1) {\r\n        arr.splice(index, 1);\r\n        arr.splice(pos, 0, item);\r\n    }\r\n};\r\nexport const reFill = (arr, values) => {\r\n    arr.splice(0, arr.length, ...values);\r\n};\r\n\r\n\r\nexport default {\r\n    isArray, isIterable, toArray, newArray,\r\n    orderBy, orderByDesc, naturalSort, shuffle,\r\n    innerJoin, groupBy, groupJoin, count, first, last,\r\n    distinctBy, distinct, union, take, skip, page, countPages,\r\n    min, max, sum, average, toMap, sameContent,\r\n    query, getEnumerator,\r\n    move, reFill\r\n};\r\n","class TreeNode {\r\n\tconstructor(value, parent, tree) {\r\n\t\tthis._value = value;\r\n\t\tthis._parent = parent;\r\n\t\tthis._level = parent ? parent.level + 1 : 0;\r\n\t\tthis._tree = tree;\r\n\t\tthis._children = [];\r\n\t}\r\n\r\n\tget value() {\r\n\t\treturn this._value;\r\n\t}\r\n\tset value(value) {\r\n\t\tthis._value = value;\r\n\t}\r\n\tget parent() {\r\n\t\treturn this._parent;\r\n\t}\r\n\tget level() {\r\n\t\treturn this._level;\r\n\t}\r\n\tget children() {\r\n\t\treturn this._children;\r\n\t}\r\n\tset children(value) {\r\n\t\tthis._children = value;\r\n\t}\r\n\tadd(value, o = {}) {\r\n\t\to.parents = [this];\r\n\t\tthis._tree.add(value, o);\r\n\t}\r\n\tgetOffspring() {\r\n\t\treturn this._tree.getOffspring(this);\r\n\t}\r\n\tgetAncestors() {\r\n\t\treturn this._tree.getAncestors(this);\r\n\t}\r\n\tgetRoot() {\r\n\t\treturn this._tree.getRoots(this)[0];\r\n\t}\r\n\r\n\t*[Symbol.iterator]() {\r\n\t\tfor (const child of this.children) {\r\n\t\t\tyield child;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport default TreeNode;","import TreeNode from './tree-node';\r\nimport { isIterable, toArray, distinct } from '../utilities/array-utility';\r\n\r\nexport const toNodes = ({ tree, nodes }) => {\r\n    if (!isIterable(nodes)) {\r\n        //if (nodes instanceof TreeNode) {\r\n        nodes = [nodes];\r\n    }\r\n    return toArray(nodes).flatMap(node => node instanceof TreeNode ? node : tree.getNodes(node));\r\n};\r\n\r\nexport const findParents = ({ tree, value, fkSelector, parentsSelector }) => {\r\n    const parentValues = parentsSelector ? parentsSelector(value) : [];\r\n    const nodes = tree.getNodes();\r\n    const parentFilter = fkSelector\r\n        ? n => n.value !== value && fkSelector(value, n.value)\r\n        : n => parentValues.includes(n.value);\r\n    return nodes.filter(parentFilter);\r\n};\r\n\r\nexport const addValue = ({ tree, value, fkSelector, parentsSelector }) => {\r\n    const addedNodes = [];\r\n    console.debug(\"AddValue\", { tree, value, fkSelector, parentsSelector });\r\n    let parentNodes = findParents({ tree, value, fkSelector, parentsSelector });\r\n    if (!parentNodes.length) {\r\n        parentNodes = [null];\r\n    }\r\n    for (const parentNode of parentNodes) {\r\n        const node = new TreeNode(value, parentNode, tree);\r\n        tree._nodes.add(node);\r\n        addedNodes.push(node);\r\n    };\r\n    return addedNodes;\r\n};\r\n\r\n\r\nexport default {\r\n    toNodes,\r\n    addValue\r\n};"],"sourceRoot":""}